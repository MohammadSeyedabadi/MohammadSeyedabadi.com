const enPosts = {
    2025: [
      {
        local: true,
        lang: "en",
        slug: "performance-tuning-in-database",
        otherPageSlug: "تنظیم-عملکرد-در-دیتابیس",
        title: "Performance tuning in database",
        createdAt: "2025-05-19",
        lastModified: "2025-05-19",
        formattedCreatedAt: "May 19, 2025",
        formattedCreatedAtMonthDay: "May 19",
        faFormatedCreatedAt: "۲۹ اردیبهشت ۱۴۰۴",
        faFormattedCreatedAtMonthDay: "۲۹ اردیبهشت",
        faYear: "۱۴۰۴",
        formattedLastModified: "May 19, 2025",
        faFormatedLastModified: "۲۹ اردیبهشت ۱۴۰۴",
        image: "/images/posts/performance-tuning-in-database/database.png",
        excerpt: "An overview of database performance tuning",
        tags: [
          "database"
        ],
        content: "Some time ago, I did some research on database performance tuning and I want to write about it here. In the following, each of the following topics will be briefly discussed.\n\n1. [Definition of performance tuning](#Definition-of-performance-tuning)\n2. [An overview of database](#An-overview-of-database)\n3. [SQL Vs NoSQL](#SQL-Vs-NoSQL)\n4. [Performance tuning from an overall perspective](#Performance-tuning-from-an-overall-perspective)\n5. [Performance tuning in SQL-Software level](#Performance-tuning-in-SQL-Software-level)\n6. [Performance tuning in SQL-Hardware level](#Performance-tuning-in-SQL-Hardware-level)\n7. [Performance tuning in NoSQL-Software level](#Performance-tuning-in-NoSQL-Software-level)\n8. [Performance tuning in NoSQL-Hardware level](#Performance-tuning-in-NoSQL-Hardware-level)\n    1. [Replication and Sharding](#Replication-and-Sharding)\n9. [Performance tuning in network](#Performance-tuning-in-network)\n10. [Is Performance tuning always done ?](#Is-Performance-tuning-always-done-?)\n\n## Definition of performance tuning\n\nPerformance tuning is the process of analyzing and optimizing a system (database, network, or even automobile) with the goal of achieving the best possible performance under given constraints.\n\n## An overview of database\n\nWhat is a database? A database is like a large filing cabinet, except it's electronic and stores digital information instead of paper documents. A database stores, manages, and retrieves information. A database is essentially software that runs on a computer called a server. A database can also be a collection of databases, servers, and the network that connects the servers. Now, let's look at the two main types of databases that we encounter.\n\n## SQL Vs NoSQL\n\nSQL databases, also known as relational databases, store data in tables. Tables have rows and columns, and each table can have relationships with other tables.\n\n![relational databases](/images/posts/performance-tuning-in-database/relational-database.png)\n\nIn NoSQL databases we have more flexibility, meaning we can store data in different formats such as:\n1. document\n2. Key-Value pairs\n3. graph\n4. wide column\n\n![Data Structure in NoSQL](/images/posts/performance-tuning-in-database/nosql-data-structure.png)\n\nEach of these two database models has its own advantages and disadvantages, but in many projects there is no need to prefer one over the other and the best thing to do is to use a combination of both.\n\n| Aspects | SQL | NoSQL |\n| :----- | :----- | :----- |\n| Type | Relational | Non-relational |\n| Data | Structured | Structured, semi-structured, and unstructured |\n| Schema | Static | Dynamic |\n| Scalability | Vertical | Horizontal |\n| Transactions | ACID | Eventual consistency |\n| Flexibility | Less | More |\n| Language | Structured Query Language (SQL) | Languages ​​specific to each NoSQL database |\n| Use cases | Suitable for complex queries and transactions | Suitable for rapid development and scalability |\n| Examples | MySQL, PostgreSQL, Oracle, SQLite | MongoDB, Cassandra, Redis, Elasticsearch |\n\nUsing SQL and NoSQL together in a project is a powerful technique, often known as __polyglot persistence__, and is a design approach that leverages the strengths of each database type to manage different types of data and tasks. Of course, this method is for large projects and is not suitable for small projects.\n\n## Performance tuning from an overall perspective\n\nPerformance tuning is the process of optimizing a system for the highest level of performance. Take a BMW GTR M3 for example. This car is great in normal mode, but if our goal is to participate in competitions, we need to make some changes to the car. For example, putting tires that have less friction or increasing engine power. Of course, note that although these changes are great for racing, they are not good at all for normal conditions. For example, the tires must have a standard level of friction so that the car has the necessary safety and the engine noise should not bother the citizens, in addition, these changes have a much higher maintenance cost and this means spending on things that may never be used.\n\nImage of a BMW GTR M3 before and after Performance tuning:\n\n![BMW GTR M3](/images/posts/performance-tuning-in-database/BMW.png)\n\nPerformance tuning in a database is a process that covers everything from query optimization to hardware resource management, and it is not a one-time task, but an ongoing process that involves monitoring, diagnosing, and modifying system behavior, just like we have in the case of car racing.\n\n![Monitoring Databases and Cars](/images/posts/performance-tuning-in-database/f1-monitor.png)\n\nIn short, performance tuning in a database is important for the following reasons:\n1. __Speed:__ Reduce query execution time\n2. __Scalability:__ Manage users as workloads increase\n3. __Resource efficiency:__ Optimize CPU, memory, and ... usage\n\nEach of these can be achieved by changes in software or hardware architecture. I will give a very general explanation below, but if this topic is to be learned well and implemented in practice, you should go to reference sources, such as this book:\n\n![Database Performance Tuning Book](/images/posts/performance-tuning-in-database/database-tuning.jpg)\n\n## Performance tuning in SQL-Software level\n\n__Query Optimization:__\n1. __Query Rewriting:__ Write the names of the required columns instead of using SELECT *\n2. __Automated Tools:__ Use tools to analyze how queries are executed and identify bottlenecks\n\n__Indexing Strategies:__\n1. __Create appropriate indexes:__ Index columns that are frequently used\n2. __Periodic Index Checking:__ Periodically check indexes to keep the program optimized\n\n__Database Configuration:__\n1. __Parameter Setting:__ Modify configuration files to allocate appropriate memory, cache size, and disk I/O settings\n2. __Connection pooling:__ A technique for optimally managing database access\n\n__Storage Mechanisms:__\n1. __Result Caching:__ Store the results of common queries\n2. __Memory Storage:__ Store frequently used data on other databases, to reduce pressure on the main database\n\n## Performance tuning in SQL-Hardware level\n\n__Upgrading various components:__\n1. __Hard:__ Using SSD instead of HDD for faster data access\n2. __RAM:__ For faster processing\n3. __CPU:__ Multi-core or faster CPUs for increased speed and complex processing\n\n__Server configuration:__\n1. __Load balancing:__ Distributing the load of queries across multiple servers\n\n## Performance tuning in NoSQL-Software level\n\n__Scaling:__\n1. __Horizontal Scaling:__ Distributing data across multiple servers to manage load and optimize access speed\n2. __Replication and Consistency:__ How fast data is distributed across other servers\n3. __Shard keys:__ Choosing good shard keys to divide data evenly and support search patterns\n4. __Caching:__ Just like SQL, storing frequently used data in a way that is optimized for access\n\n__Data Modeling and Schema Design:__\n1. __Choosing the right data model:__ We choose a data model according to the situation\n2. __Flexible Schema:__ Organizing information in a way that makes it fast to find what we are looking for\n3. __Denormalization:__ Based on user requests, lists are created (made of combinations of Several lists (which may contain duplicate information, but since they are widely used, the system speed increases.\n\n## Performance tuning in NoSQL-Hardware level\n\n1. __Distributed Node Optimization:__ Each node in a cluster should be balanced\n2. __Network performance:__ Since data in NoSQL environments is often distributed across multiple servers or even data centers, the network can have a significant impact\n3. __Replication and Sharding:__ NoSQL databases often use Replication to distribute data across nodes and Sharding to partition and ensure data availability.\n\nSo far, I have briefly mentioned some aspects of database performance tuning. Next, I will mention some aspects of network performance tuning because, as I mentioned before, for example, in the case of Replication and Sharding, we need communication between different nodes, so the role of the network becomes more colorful here. But before I give examples of performance tuning about the network, I think it would be good to explain Replication and Sharding a little more. Just note that we can have this method in SQL or a combination of SQL and NoSQL in some way.\n\n### Replication and Sharding\n\nSharding and Replication are both fundamental strategies in NoSQL databases and serve distinct purposes in how data is managed and scaled.\n\n__Replication__\n\nReplication creates multiple copies of the same data across servers (nodes). The main purpose is to ensure high availability and fault tolerance. If one node fails, other nodes have the same data and can continue to serve queries. This method significantly increases the system's resilience in the face of hardware failures or network problems.\n\n__Consistency considerations:__ Operations such as data deletion must be synchronized between copies, either synchronously or asynchronously.\n\n__Sharding__\n\nSharding divides a large data set into smaller, more manageable chunks called shards. This allows the system to spread the workload across multiple nodes and increase throughput.\n\n__Considerations for managing complex queries:__ Queries that target a specific shard are fast, but queries that span multiple shards may add complexity to the system.\n\n## Performance tuning in network\n\n1. __Bandwidth Optimization:__ Adjusting the amount of data that can be sent over the network\n2. __Latency Reduction:__ Configuring routing protocols to choose a better path, i.e. reducing the number of hops between the source and destination\n3. __Hardware setup:__ Using high-quality network tools and configuring them properly\n\n## Is Performance tuning always done ?\n\n![Venn Diagram to Describe an Engineer](/images/posts/performance-tuning-in-database/venn-en.png)\n\nThe image above is a Venn diagram to describe an engineer, any engineer. According to this diagram, engineers should do their work quickly and dirty. But this will cost a lot in the long run or even in the short run, so you should try to proceed with principles from the very beginning."
      }
    ],
    2023: [
      {
        local: true,
        lang: "en",
        slug: "how-to-create-a-multilevel-dropdown-menu-in-react",
        otherPageSlug: "نحوه-ایجاد-یک-منوی-چند-سطحی-در-ریکت",
        title: "How to create a multilevel dropdown menu in React",
        createdAt: "2023-11-19",
        lastModified: "2023-11-19",
        formattedCreatedAt: "November 19, 2023",
        formattedCreatedAtMonthDay: "November 19",
        faFormatedCreatedAt: "۲۸ آبان ۱۴۰۲",
        faFormattedCreatedAtMonthDay: "۲۸ آبان",
        faYear: "۱۴۰۲",
        formattedLastModified: "November 19, 2023",
        faFormatedLastModified: "۲۸ آبان ۱۴۰۲",
        image: "/images/posts/how-to-create-a-multilevel-dropdown-menu-in-react/how-to-create-a-multilevel-dropdown-menu-in-react.png",
        excerpt: "Multilevel dropdown menus are a staple of web design. With the ability to provide multiple options to select from, they make navigation bars dynamic and organized.",
        tags: [
          "front-end",
          "algorithm",
          "reactjs"
        ],
        content: "This tutorial is a simplified version of [this tutorial](https://blog.logrocket.com/how-create-multilevel-dropdown-menu-react/) written by Ibadehin Mojeed.\nIf you want a complete explanation, you have to read his article. He also has another article where he explans\nhow to make dropdown menus with CSS. You could check that out [here.](https://blog.logrocket.com/making-dropdown-menus-css/) At the end we will have something like this:\n\n![Final-outcome-react-multilevel-dropdown-menu-project](https://raw.githubusercontent.com/MohammadSeyedabadi/MohammadSeyedabadi.com/refs/heads/master/public/images/posts/how-to-create-a-multilevel-dropdown-menu-in-react/img1-Final-outcome-react-multilevel-dropdown-menu-project.gif)\n\nSo let's start with our code. If you want to create a multilevel dropdown menu, one good way is\nto use recursive functions. As in [GeeksForGeeks](https://www.geeksforgeeks.org/recursive-functions/) explained:\n\n> A Recursive function can be defined as a routine that calls itself directly or indirectly. In other words, a recursive function is a function that solves a problem by solving smaller instances of the same problem. This technique is commonly used in programming to solve problems that can be broken down into simpler, similar subproblems.\n\nBasically a Recursive function is a function that calls it self, something like this:\n\n```js\n myRecursiveFunction(){\n    // some code\n    myRecursiveFunction()\n   // some code\n}\n```\n\nWell you may say that _**it causes an infinite loop.**_ That's right but not if we have a condition that stops the function call in a certain state, something like:\n\n```js\nmyRecursiveFunction(){\n   // some code\n   if(true){\n    return\n   }\n   myRecursiveFunction()\n   // some code\n}\n```\n\nIt is also good to know that any problems that you can solve using a recursive function, will always have an alternative looping solution, but most of the time a recursive function makes our life easier.\nSo in our case, imagine that we have an array of menus and submenus like this:\n\n```js\n[\n  {\n    title: \"Home\",\n    url: \"/\",\n  },\n  {\n    title: \"Services\",\n    url: \"/services\",\n    submenu: [\n      {\n        title: \"web design\",\n        url: \"web-design\",\n      },\n      {\n        title: \"web development\",\n        url: \"web-dev\",\n        submenu: [\n          {\n            title: \"Frontend\",\n            url: \"frontend\",\n          },\n          {\n            title: \"Backend\",\n            submenu: [\n              {\n                title: \"NodeJS\",\n                url: \"node\",\n              },\n              {\n                title: \"PHP\",\n                url: \"php\",\n              },\n            ],\n          },\n        ],\n      },\n      {\n        title: \"SEO\",\n        url: \"seo\",\n      },\n    ],\n  },\n  {\n    title: \"About\",\n    url: \"/about\",\n    submenu: [\n      {\n        title: \"Who we are\",\n        url: \"who-we-are\",\n      },\n      {\n        title: \"Our values\",\n        url: \"our-values\",\n      },\n    ],\n  },\n];\n```\n\nWe can write a function which is responsible for rendering our whole navigation, i called it Header just as Ibadehin Mojeed did,\nbecause our header tag which is inside of this function, wraps everything, but you could call it whatever you want. I also wrote a usestate for small screens.\n\n```jsx\nexport default function Header() {\n  const [toggle, setToggle] = useState(false);\n  return (\n    <header className={` ${toggle ? \"active\" : \"\"} `}>\n      <div className=\"nav-area\">\n        <Link href=\"/\" className=\"logo\">\n          logo\n        </Link>\n        {menuItems.length ? (\n          <>\n            <nav>\n              <ul className=\"menus\">\n                {menuItems.map((menu, index) => {\n                  const depthLevel = 0;\n                  return (\n                    <MenuItems\n                      items={menu}\n                      key={index}\n                      depthLevel={depthLevel}\n                    />\n                  );\n                })}\n              </ul>\n            </nav>\n            <div\n              className=\"menuToggle\"\n              onClick={() => setToggle(toggle === true ? false : true)}\n            ></div>\n          </>\n        ) : null}\n      </div>\n    </header>\n  );\n}\n\nfunction MenuItems({ items, depthLevel }) {\n  const [dropdown, setDropdown] = useState(false);\n\n  function onMouseEnter() {\n    window.innerWidth > 960 && setDropdown(true);\n  }\n\n  function onMouseLeave() {\n    window.innerWidth > 960 && setDropdown(false);\n  }\n\n  return (\n    <li\n      className=\"menu-items\"\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n    >\n      {items.submenu ? (\n        <>\n          <button\n            type=\"button\"\n            aria-haspopup=\"menu\"\n            aria-expanded={dropdown ? \"true\" : \"false\"}\n            onClick={() => setDropdown((prev) => !prev)}\n          >\n            {items.title}{\" \"}\n            {depthLevel > 0 ? <span>&raquo;</span> : <span className=\"arrow\" />}\n          </button>\n          <Dropdown\n            depthLevel={depthLevel}\n            submenus={items.submenu}\n            dropdown={dropdown}\n          />\n        </>\n      ) : (\n        <Link href={items.url}>{items.title}</Link>\n      )}\n    </li>\n  );\n}\n\nfunction Dropdown({ depthLevel, submenus, dropdown }) {\n  depthLevel = depthLevel + 1;\n  const dropdownClass = depthLevel > 1 ? \"dropdown-submenu\" : \"\";\n\n  return (\n    <ul className={` dropdown ${dropdownClass} ${dropdown ? \"show\" : \"\"} `}>\n      {submenus.map((submenu, index) => (\n        <MenuItems items={submenu} key={index} depthLevel={depthLevel} />\n      ))}\n    </ul>\n  );\n}\n```\n\nAs you see, there is a MenuItems function inside of Header function, which is responsible for\ncreating submenus ( lis ) inside of our menus ( uls ), or maybe just single submenus ( lis ).\nOur MenuItems function is our recursive function, it calls itself indirectly by Dropdown function and\nthat **_items.submenu ?_** is its termination condition, if that condition is false, then it just simply creates a\nLink, but if that is true, then it will create a button( so the user can click or hover to see submenu/s )\nand then it calls itself by Dropdown function to again, create either a Link or a button.\n\nHere is the css code to make it feel more like a navigation:\n\n```css\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  font-family: sans-serif;\n}\n\nheader {\n  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.07), 0 1px 2px 0 rgba(0, 0, 0, 0.05);\n  color: #212529;\n}\n\n.nav-area {\n  display: flex;\n  align-items: center;\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 10px 20px;\n}\n\n.logo {\n  text-decoration: none;\n  font-size: 25px;\n  color: inherit;\n  margin-right: 20px;\n}\n\n.menus {\n  display: flex;\n  align-items: center;\n  flex-wrap: wrap;\n  list-style: none;\n}\n\n.menu-items {\n  position: relative;\n  font-size: 14px;\n}\n\n.menu-items a {\n  display: block;\n  font-size: inherit;\n  color: inherit;\n  text-decoration: none;\n}\n\n.menu-items button {\n  display: flex;\n  align-items: center;\n  color: inherit;\n  font-size: inherit;\n  border: none;\n  background-color: transparent;\n  cursor: pointer;\n  width: 100%;\n}\n\nbutton span {\n  margin-left: 3px;\n}\n\n.menu-items > a,\n.menu-items button {\n  text-align: left;\n  padding: 0.7rem 1rem;\n}\n\n.menu-items a:hover,\n.menu-items button:hover {\n  background-color: #f2f2f2;\n}\n\n.arrow::after {\n  content: \"\";\n  display: inline-block;\n  margin-left: 0.28em;\n  vertical-align: 0.09em;\n  border-top: 0.42em solid;\n  border-right: 0.32em solid transparent;\n  border-left: 0.32em solid transparent;\n}\n\n.dropdown {\n  position: absolute;\n  left: 0;\n  left: auto;\n  box-shadow: 0 10px 15px -3px rgba(46, 41, 51, 0.08), 0 4px 6px -2px rgba(71, 63, 79, 0.16);\n  font-size: 0.875rem;\n  z-index: 9999;\n  min-width: 10rem;\n  padding: 0.5rem 0;\n  list-style: none;\n  background-color: #fff;\n  border-radius: 0.5rem;\n  display: none;\n}\n\n.dropdown.show {\n  display: block;\n}\n\n.dropdown .dropdown-submenu {\n  position: absolute;\n  left: 100%;\n  top: -7px;\n}\n\n@media (max-width: 1300px) {\n  nav {\n    display: none;\n    max-height: 50vh;\n    overflow-x: hidden;\n    overflow-y: auto;\n  }\n\n  .menus {\n    padding-left: 0px;\n  }\n\n  .dropdown .dropdown-submenu {\n    position: initial;\n  }\n  .dropdown {\n    position: relative;\n    border-radius: 0;\n    box-shadow: none;\n  }\n  header nav {\n    position: absolute;\n    width: 100%;\n    top: 70px;\n    left: 0;\n    background-color: #e5e2ff;\n  }\n  header.active nav {\n    display: initial;\n  }\n  header nav ul li {\n    width: 100%;\n  }\n  header nav ul li ul {\n    position: relative;\n    width: 100%;\n    left: 0;\n  }\n  header ul li ul li ul {\n    top: 0;\n    left: 0;\n  }\n  header nav ul li:hover ul li {\n    background-color: #ffffff;\n  }\n\n  .menuToggle {\n    position: relative;\n    width: 40px;\n    height: 50px;\n    cursor: pointer;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    margin-left: auto;\n  }\n\n  .menuToggle::before {\n    content: \"\";\n    position: absolute;\n    width: 100%;\n    height: 3px;\n    background-color: #000000;\n    transform: translateY(-12px);\n    box-shadow: 0 12px #000000;\n  }\n\n  .menuToggle::after {\n    content: \"\";\n    position: absolute;\n    width: 100%;\n    height: 3px;\n    background-color: #000000;\n    transform: translateY(12px);\n  }\n  header.active .menuToggle::before {\n    transform: rotate(45deg);\n    box-shadow: 0 0 #000000;\n  }\n  header.active .menuToggle::after {\n    transform: rotate(315deg);\n  }\n}\n```\n\n## Conclusion\n\nSo that was it for this tutorial. If you still didn't understand what a recursive function does, that's totally fine, because i explained it in short, so go ahead and google it :))"
      }
    ]
  };

const faPosts = {
    2025: [
      {
        local: true,
        lang: "fa",
        slug: "تنظیم-عملکرد-در-دیتابیس",
        otherPageSlug: "performance-tuning-in-database",
        title: "تنظیم عملکرد (Performance tuning) در دیتابیس",
        createdAt: "2025-5-19",
        lastModified: "2025-5-19",
        formattedCreatedAt: "May 19, 2025",
        formattedCreatedAtMonthDay: "May 19",
        faFormatedCreatedAt: "۲۹ اردیبهشت ۱۴۰۴",
        faFormattedCreatedAtMonthDay: "۲۹ اردیبهشت",
        faYear: "۱۴۰۴",
        formattedLastModified: "May 19, 2025",
        faFormatedLastModified: "۲۹ اردیبهشت ۱۴۰۴",
        image: "/images/posts/performance-tuning-in-database/database.png",
        excerpt: "نگاهی کلی به تنظیم عملکرد در دیتابیس",
        tags: [
          "دیتابیس"
        ],
        content: "چند وقت پیش در مورد تنظیم عملکرد در دیتابیس تحقیقی انجام دادم و در اینجا میخوام در موردش بنویسم. در ادامه هر کدوم از موضوعات زیر به صورت مختصر مورد بررسی قرار میگیره.\n\n1. [تعریف تنظیم عملکرد](#تعریف-تنظیم-عملکرد)\n2. [مروری بر مبحث دیتابیس](#مروری-بر-مبحث-دیتابیس)\n3. [مقایسه SQL و NoSQL](#مقایسه-SQL-و-NoSQL)\n4. [Performance tuning از دید کلی](#Performance-tuning-از-دید-کلی)\n5. [Performance tuning در SQL در سطح نرم افزار](#Performance-tuning-در-SQL-در-سطح-نرم-افزار)\n6. [Performance tuning در SQL در سطح سخت افزار](#Performance-tuning-در-SQL-در-سطح-سخت-افزار)\n7. [Performance tuning در NoSQL در سطح نرم افزار](#Performance-tuning-در-NoSQL-در-سطح-نرم-افزار)\n8. [Performance tuning در NoSQL در سطح سخت افزار](#Performance-tuning-در-NoSQL-در-سطح-سخت-افزار)\n    1. [Replication و Sharding](#Replication-و-Sharding)\n9. [Performance tuning در شبکه](#Performance-tuning-در-شبکه)\n10. [آیا Performance tuning همیشه انجام میشه ؟](#آیا-Performance-tuning-همیشه-انجام-میشه-؟)\n\n## تعریف تنظیم عملکرد\n\nتنظیم عملکرد (Performance tuning) فرایند تجزیه و تحلیل و بهینه سازی یک سیستم (دیتابیس، شبکه یا حتی اتوموبیل) با هدف دستیابی به بهترین عملکرد ممکن تحت محدودیت‌های معین هست.\n\n## مروری بر مبحث دیتابیس\n\nدیتابیس چیست؟ دیتابیس مثل یک کمد بایگانی بزرگ هست، البته الکترونیکی و به جای اسناد کاغذی، اطلاعات دیجیتالی رو ذخیره میکنه. یک دیتابیس، ذخیره، مدیریت و بازیابی اطلاعات رو انجام میده. دیتابیس در اصل یک نرم افزار هست و روی یک کامپیوتر اجرا میشه که به این کامپیوتر سرور میگن. البته ممکنه به مجموعه‌ی دیتابیس، سرورها و شبکه ای که سرور هارو بهم وصل میکنه هم بگن دیتابیس. حالا بیایید به دو دسته اصلی دیتابیس که با اونها مواجه میشیم بپردازیم.\n\n##  مقایسه SQL و NoSQL\n\nدیتابیس SQL که به عنوان دیتابیس رابطه‌ای (Rational) هم شناخته میشه، اطلاعات رو در جدول‌ها ذخیره میکنه. جدول ها دارای سطر و ستون هستند و هر جدول میتونه با جدول های دیگه دارای رابطه باشه.\n\n\n![دیتابیس رابطه ای](/images/posts/performance-tuning-in-database/relational-database.png)\n\nدر دیتابیس NoSQL انعطاف پذیری بیشتری داریم، به این معنی که میتونیم داده ها رو در قالب های مختلفی مثل:\n1. document\n2. Key-Value pairs\n3. graph\n4. wide column\n\nذخیره کنیم.\n\n![ساختمان داده ها در NoSQL](/images/posts/performance-tuning-in-database/nosql-data-structure.png)\n\nهر کدوم از این دو مدل دیتابیس، مزایا و معایب خودشون رو دارن، اما توی خیلی از پروژه ها نیازی نیستش که یکی رو به اون یکی دیگه ترجیح بدیم و بهترین کار اینه که ترکیبی از هر دو رو استفاده بکنیم.\n\n| جنبه ها | SQL | NoSQL |\n| -----: | -----: | -----: |\n| نوع    | رابطه ای | غیر رابطه ای |\n| داده ها | ساختار یافته | ساختار یافته، نیمه ساختار یافته و بدون ساختار |\n| طرحواره (schema) | ایستا | پویا |\n| مقیاس پذیری | عمودی | افقی |\n| Transactions (تراکنش ها) | ACID | Eventual consistency |\n| انعطاف پذیری | کمتر | بیشتر |\n| زبان | Structured Query Language (SQL) | زبان های مختص هر دیتابیس NoSQL |\n| موارد استفاده (Use cases) | مناسب برای Query ها و تراکنش های پیچیده | مناسب برای توسعه سریع و مقیاس پذیری |\n| نمونه ها | MySQL, PostgreSQL, Oracle, SQLite | MongoDB, Cassandra, Redis, Elasticsearch |\n\nاستفاده ی همزمان از SQL و NoSQL در یک پروژه، یک روش قدرتمند هست که اغلب به عنوان __polyglot persistence__ شناخته میشه و یک رویکرد طراحی هست، که از نقاط قوت هر نوع دیتابیس برای مدیریت انواع مختلف داده ها و کارها استفاده میکنه. البته که این روش برای پروژه های بزرگ هست و به درد پروژه های کوچیک نمیخوره.\n\n## Performance tuning از دید کلی\n\nPerformance tuning فرایند بهینه سازی یک سیستم برای بالاترین سطح کارایی هست. برای مثال یک BMW GTR M3 رو در نظر بگیرید. این ماشین در حالت عادی هم فوق العاده هست، ولی اگر هدف ما شرکت در مسابقات باشه، باید یکسری تغییرات رو روی ماشین انجام بدیم. مثلا گذاشتن تایر هایی که اصطکاک کمتری دارن و یا افزایش قدرت موتور. البته توجه کنید با اینکه این تغییرات برای مسابقه عالی هستند، اما برای شرایط عادی اصلا خوب نیستن، برای مثال تایر ها باید میزان اصطکاک استانداردی داشته باشن تا ماشین امنیت لازم رو داشته باشه و صدای موتور نباید شهروند ها رو اذیت بکنه، ضمن اینکه این تغییرات، هزینه نگهداری خیلی بالاتری داره و این یعنی هزینه برای چیز هایی که شاید هیچ وقت استفاده نشن.\n\nتصویر یک BMW GTR M3 قبل و بعد از Performance tuning :\n\n![BMW GTR M3](/images/posts/performance-tuning-in-database/BMW.png)\n\nPerformance tuning در دیتابیس فرایندی هست که همه چیز، از بهینه سازی Query ها گرفته تا مدیریت منابع سخت افزاری رو پوشش میده و این یک کار یکباره نیست، بلکه یک فرایند مداوم هست که شامل نظارت، تشخیص و اصلاح رفتار سیستم میشه، همونطور که درمورد مسابقات اتوموبیل رانی همچنین چیزی داریم.\n\n![مانیتور کردن دیتابیس و اتوموبیل](/images/posts/performance-tuning-in-database/f1-monitor.png)\n\nبه طور خلاصه میشه گفت که Performance tuning در دیتابیس به این دلایل اهمیت داره:\n1. __سرعت :__ کاهش زمان اجرای Query ها\n2. __مقیاس پذیری :__ مدیریت کاربران با افزایش حجم کار\n3. __بهره وری منابع :__ بهینه سازی استفاده از CPU، حافظه و ...\n\nکه هر کدوم از اینها میتونه با تغییراتی در معماری نرم افزار یا سخت افزار به دست بیاد. من در ادامه توضیحات خیلی کلی ای میدم ولی اگر قرار باشه که این موضوع به خوبی یاد گرفته بشه و در عمل هم پیاده سازی بشه، باید رفت سراغ منابع مرجع، مثل این کتاب :\n\n![کتاب تنظیم عملکرد دیتابیس](/images/posts/performance-tuning-in-database/database-tuning.jpg)\n\n## Performance tuning در SQL در سطح نرم افزار\n\n__بهینه سازی Query ها :__\n1. __باز نویسی Query ها :__ نوشتن نام ستون های مورد نیاز به جای استفاده از * SELECT\n2. __ابزار های اتوماتیک :__ استفاده از ابزار هایی برای تجزیه و تحلیل نحوه اجرای Query ها و شناسایی گلوگاه ها\n\n__استراتژی های Index گذاری :__\n1. __ایجاد Index های مناسب :__ Index کردن ستون هایی که مکررا از آنها استفاده میشود\n2. __بررسی متناوب Index ها :__ بررسی متناوب Index ها تا برنامه بهینه بماند\n\n__کانفیگ کردن دیتابیس :__\n1. __تنظیم پارامتر ها :__ تغییر فایل های پیکربندی برای تخصیص حافظه مناسب، اندازه حافظه پنهان و تنظیمات ورودی-خروجی دیسک\n2. __Connection pooling :__ تکنیکی برای مدیریت بهینه دسترسی به دیتابیس\n\n__مکانیزم های ذخیره سازی :__\n1. __ذخیره سازی نتایج (Result caching) :__ ذخیره نتایج Query های رایج\n2. __ذخیره سازی حافظه :__ ذخیره کردن داده های پر کاربرد روی دیتابیس های دیگر، تا روی دیتابیس اصلی فشار کمتری بیاد\n\n## Performance tuning در SQL در سطح سخت افزار\n\n__ارتقا دادن اجزای مختلف :__\n1. __هارد :__ استفاده از هارد SSD به جای HDD برای دسترسی سریعتر به داده ها\n2. __رم :__ برای پردازش سریعتر\n3. __CPU :__ سی پی یو های چند هسته ای یا سریعتر برای افزایش سرعت و پردازش های پیچیده\n\n__پیکربندی های سرور (Server configuration) :__\n1. __متعادل سازی بار (Load balancing) :__ توزیع بار Query ها بین چندین سرور\n\n## Performance tuning در NoSQL در سطح نرم افزار\n\n__تقسیم بندی :__\n1. __تقسیم بندی افقی (Horizontal Scaling) :__ توزیع داده ها بین چندین سرور برای مدیریت بار و بهینه سازی سرعت دسترسی\n2. __تکرار و ثبات (Replication and Consistency) :__ داده ها با چه سرعتی در میان سرور های دیگر توزیع شوند\n3. __کلید های تقسیم بندی (Shard keys) :__ انتخاب کلید های تقسیم بندی خوب تا داده ها رو به صورت مساوی تقسیم کنه و از الگو های جستوجو پشتیبانی کنه\n4. __ذخیره سازی (Caching) :__ درست همانند SQL، ذخیره سازی داده های پر کاربرد به گونه ای که دسترسی به آنها بهینه باشد\n\n__مدل سازی داده ها و طراحی طرحواره (Data Modeling and Schema Design) :__\n1. __انتخاب data model مناسب :__ متناسب با شرایط، یک data model انتخاب میکنیم\n2. __طرحواره منعطف (Flexible Schema) :__ سازماندهی اطلاعات به شکلی که پیدا کردن چیزی که دنبال اش هستیم سریع باشه\n3. __غیر نرمالسازی (Denormalization) :__ بر اساس درخواست های کاربران، لیست هایی درست میشود ( ساخته شده از ترکیب چند لیست ) که ممکن است در آن اطلاعات تکراری باشد، اما از آنجا که پر کاربرد هست، سرعت سیستم بالا میره\n\n## Performance tuning در NoSQL در سطح سخت افزار\n\n1. __بهینه سازی گره (نود) های توزیع شده :__ هر نود در یک خوشه (Cluster) باید متعادل باشد\n2. __عملکرد شبکه (Network performance) :__ از آنجایی که داده ها در محیط های NoSQL اغلب در چندین سرور یا حتی مراکز داده (Data center) پخش میشوند، شبکه می‌تواند تأثیر قابل توجهی داشته باشد\n3. __تکثیر و تقسیم بندی (Replication and Sharding) :__ دیتابیس های NoSQL اغلب از Replication برای پخش داده ها در نود ها و از Sharding برای تقسیم بندی و اطمینان از در دسترس بودن داده ها استفاده میشود.\n\nتا اینجای کار، مواردی از تنظیم عملکرد در دیتابیس رو به صورت خلاصه گفتم. در ادامه مواردی رو هم از تنظیم عملکرد در شبکه میگم چون همونطور که قبلا هم اشاره کردم، مثلا در مورد Replication و Sharding، ما نیاز به ارتباط بین نود های مختلف رو داریم پس اینجا نقش شبکه پر رنگ تر میشه. اما قبل از اینکه در مورد شبکه بخوام مثال هایی از تنظیم عملکرد بزنم، فکر میکنم خوب باشه تا Replication و Sharding رو یکم بیشتر توضیح بدم. فقط توجه کنید که ما این روش رو در SQL و یا ترکیبی از SQL و NoSQL هم به نحوی میتونیم داشته باشیم.\n\n### Replication و Sharding\n\nSharding و Replication، هر دو استراتژی های اساسی در دیتابیس های NoSQL هستند و اهداف متمایزی رو در نحوه مدیریت و مقیاس پذیری داده ها ارائه میدن.\n\n__Replication__\n\nReplication، چندین کپی از داده های مشابه رو در سرور ها (نود ها) ایجاد میکنه. هدف اصلی تضمین دسترسی بالا و تحمل خطا هست. اگر یک نود از کار بیوفته، نود های دیگه، داده های مشابه رو دارن و میتونن به ارائه Query ها ادامه بدن. با این روش انعطاف پذیری سیستم در مواجهه با خرابی های سخت افزاری یا مشکلات شبکه به طور چشمگیری زیاد میشه.\n\n__ملاحظات مربوط به سازگاری :__ عملیات هایی مثل حذف اطلاعات باید در بین کپی ها به صورت همزمان یا غیر همزمان همگام سازی بشه.\n\n__Sharding__\n\nSharding یک مجموعه داده بزرگ رو به بخش های کوچک تر و قابل مدیریت تر به نام Shard تقسیم میکنه. با این کار سیستم میتونه بار کار رو روی گره های زیادی پخش بکنه و توان عملیاتی رو بالا ببره.\n\n__ملاحظات مربوط به مدیریت Query های پیچیده :__ Query هایی که یک Shard خاص رو هدف قرار میدن، سریع هستن، اما Query هایی که چندین Shard رو پوشش میدن، ممکنه پیچیدگی هایی رو به سیستم اضافه بکنن.\n\n## Performance tuning در شبکه\n\n1. __بهینه سازی پهنای باند (Bandwidth Optimization) :__ تنظیم میزان داده ای که میشه از طریق شبکه ارسال کرد\n2. __کاهش تأخیر (Latency Reduction) :__ پیکربندی پروتکل های مسیریابی برای انتخاب مسیر بهتر، یعنی کاهش تعداد hop ها بین مبدأ و مقصد\n3. __تنظیم سخت افزار (Hardware setup):__ استفاده از ابزار های شبکه که کیفیت بالایی دارند و تنظیم درست این ابزار ها\n\n## آیا Performance tuning همیشه انجام میشه ؟\n\n![نمودار ون برای توصیف یک مهندس](/images/posts/performance-tuning-in-database/venn-fa.png)\n\nتصویر بالا یک نمودار ون برای توصیف یک مهندس هست، هر مهندسی. مطابق با این نمودار، مهندس ها باید کارهاشونو سریع و کثیف انجام بدن. اما این کار باعث به وجود اومدن هزینه های زیادی در دراز مدت و یا حتی در کوتاه مدت میشه، پس باید سعی کرد از همون اول اصولی رفت جلو."
      }
    ],
    2023: [
      {
        local: true,
        lang: "fa",
        slug: "نحوه-ایجاد-یک-منوی-چند-سطحی-در-ریکت",
        otherPageSlug: "how-to-create-a-multilevel-dropdown-menu-in-react",
        title: "نحوه ایجاد یک منوی چند سطحی در ریکت",
        createdAt: "2023-11-19",
        lastModified: "2023-11-19",
        formattedCreatedAt: "November 19, 2023",
        formattedCreatedAtMonthDay: "November 19",
        faFormatedCreatedAt: "۲۸ آبان ۱۴۰۲",
        faFormattedCreatedAtMonthDay: "۲۸ آبان",
        faYear: "۱۴۰۲",
        formattedLastModified: "November 19, 2023",
        faFormatedLastModified: "۲۸ آبان ۱۴۰۲",
        image: "/images/posts/how-to-create-a-multilevel-dropdown-menu-in-react/how-to-create-a-multilevel-dropdown-menu-in-react.png",
        excerpt: "منوهای کشویی چند سطحی جزء اصلی طراحی وب هستند. آنها با توانایی ارائه چندین گزینه برای انتخاب، نوارهای ناوبری را پویا و سازماندهی می کنند.",
        tags: [
          "فرانت-اند",
          "الگوریتم",
          "ریکت-جی-اس"
        ],
        content: "این آموزش یک نسخه ی ساده شده از [آموزشی](https://blog.logrocket.com/how-create-multilevel-dropdown-menu-react/) هست که Ibadehin Mojeed نوشته.\nاگر توضیحات کامل میخوایید، باید [این مقاله](https://blog.logrocket.com/how-create-multilevel-dropdown-menu-react/) رو بخونید. ایشون همچنین یک مقاله ی دیگه هم برای درست کردن منو با CSS داره. برای خوندنش [اینجا کلیک کنید.](https://blog.logrocket.com/how-create-multilevel-dropdown-menu-react/)\nدر آخر این آموزش یک منو مثل این داریم:\n\n![Final-outcome-react-multilevel-dropdown-menu-project](https://raw.githubusercontent.com/MohammadSeyedabadi/MohammadSeyedabadi.com/refs/heads/master/public/images/posts/how-to-create-a-multilevel-dropdown-menu-in-react/img1-Final-outcome-react-multilevel-dropdown-menu-project.gif)\n\nیک راه خوب برای اینکه یک منوی چند سطحی داشته باشیم اینه که از تابع بازگشتی استفاده کنیم. همون طور که توی GeeksForGeeks توضیح داده شده:\n\n> تابع بازگشتی را می توان به عنوان روتینی تعریف کرد که به طور مستقیم یا غیرمستقیم خود را فراخوانی می کند. به عبارت دیگر، یک تابع بازگشتی تابعی است که یک مسئله را با حل نمونه های کوچکتر از همان مسئله حل می کند. این تکنیک معمولاً در برنامه نویسی برای حل مسائلی استفاده می شود که می توانند به مسائل فرعی ساده تر و مشابه تقسیم شوند.\n\nاساسا تابع بازگشتی، تابعی هست که خودش رو فراخوانی میکنه، یک چیزی مثل این:\n\n```js\nmyRecursiveFunction(){\n   // some code\n   myRecursiveFunction()\n   // some code\n}\n```\n\nخب شاید بگید که اینجوری یک حلقه‌ی بینهایت درست میشه، این حرف درسته اما نه اگر یک شرط بنویسیم که فراخوانی تابع رو در زمان خاصی متوقف کنه. یک چیزی مثل این:\n\n```js\nmyRecursiveFunction(){\n   // some code\n   if(true){\n    return\n   }\n   myRecursiveFunction()\n   // some code\n}\n```\n\nهمچنین خوبه بدونید که هر مسئله‌ای که با تابع بازگشتی حل بشه، همیشه میتونه با حلقه‌های for هم حل بشه، اما در اکثر موارد، تابع بازگشتی کارمون رو خیلی راحت تر میکنه. خب در شرایط ما، فرض کنید یک آرایه از منو‌ها و زیر منوها داریم. به این شکل:\n\n```js\n[\n  {\n    title: \"Home\",\n    url: \"/\",\n  },\n  {\n    title: \"Services\",\n    url: \"/services\",\n    submenu: [\n      {\n        title: \"web design\",\n        url: \"web-design\",\n      },\n      {\n        title: \"web development\",\n        url: \"web-dev\",\n        submenu: [\n          {\n            title: \"Frontend\",\n            url: \"frontend\",\n          },\n          {\n            title: \"Backend\",\n            submenu: [\n              {\n                title: \"NodeJS\",\n                url: \"node\",\n              },\n              {\n                title: \"PHP\",\n                url: \"php\",\n              },\n            ],\n          },\n        ],\n      },\n      {\n        title: \"SEO\",\n        url: \"seo\",\n      },\n    ],\n  },\n  {\n    title: \"About\",\n    url: \"/about\",\n    submenu: [\n      {\n        title: \"Who we are\",\n        url: \"who-we-are\",\n      },\n      {\n        title: \"Our values\",\n        url: \"our-values\",\n      },\n    ],\n  },\n];\n```\n\nما میتونیم یک تابع بنویسیم که وظیفه‌اش نمایش همه‌ی نوبار ( navbar ) باشه، من اسمش رو گذاشتم Header همونطور که Ibadehin Mojeed هم همین کارو کرده، دلیل‌اش هم اینه که تگ هدر‌ مون که داخل این تابع هست دور همه چیز پیچیده، اما شما اسمشو هرچی بخوایید میتونید بزارید. درضمن توی این تابع برای صفحه نمایش های کوچیک از usestate استفاده کردم.\n\n```jsx\nexport default function Header() {\n  const [toggle, setToggle] = useState(false);\n  return (\n    <header className={` ${toggle ? \"active\" : \"\"} `}>\n      <div className=\"nav-area\">\n        <Link href=\"/\" className=\"logo\">\n          logo\n        </Link>\n        {menuItems.length ? (\n          <>\n            <nav>\n              <ul className=\"menus\">\n                {menuItems.map((menu, index) => {\n                  const depthLevel = 0;\n                  return (\n                    <MenuItems\n                      items={menu}\n                      key={index}\n                      depthLevel={depthLevel}\n                    />\n                  );\n                })}\n              </ul>\n            </nav>\n            <div\n              className=\"menuToggle\"\n              onClick={() => setToggle(toggle === true ? false : true)}\n            ></div>\n          </>\n        ) : null}\n      </div>\n    </header>\n  );\n}\n\nfunction MenuItems({ items, depthLevel }) {\n  const [dropdown, setDropdown] = useState(false);\n\n  function onMouseEnter() {\n    window.innerWidth > 960 && setDropdown(true);\n  }\n\n  function onMouseLeave() {\n    window.innerWidth > 960 && setDropdown(false);\n  }\n\n  return (\n    <li\n      className=\"menu-items\"\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n    >\n      {items.submenu ? (\n        <>\n          <button\n            type=\"button\"\n            aria-haspopup=\"menu\"\n            aria-expanded={dropdown ? \"true\" : \"false\"}\n            onClick={() => setDropdown((prev) => !prev)}\n          >\n            {items.title}{\" \"}\n            {depthLevel > 0 ? <span>&raquo;</span> : <span className=\"arrow\" />}\n          </button>\n          <Dropdown\n            depthLevel={depthLevel}\n            submenus={items.submenu}\n            dropdown={dropdown}\n          />\n        </>\n      ) : (\n        <Link href={items.url}>{items.title}</Link>\n      )}\n    </li>\n  );\n}\n\nfunction Dropdown({ depthLevel, submenus, dropdown }) {\n  depthLevel = depthLevel + 1;\n  const dropdownClass = depthLevel > 1 ? \"dropdown-submenu\" : \"\";\n\n  return (\n    <ul className={` dropdown ${dropdownClass} ${dropdown ? \"show\" : \"\"} `}>\n      {submenus.map((submenu, index) => (\n        <MenuItems items={submenu} key={index} depthLevel={depthLevel} />\n      ))}\n    </ul>\n  );\n}\n```\n\nهمونطور که میبینید یک تابع MenuItems داخل تابع Header هست، که وظیفه‌اش ساختن زیر منو ( ها ) داخل منو ( ها ) هست. تابع MenuItems همون تابع بازگشتی ما هست. این تابع خودش رو به صورت غیر مستقیم و توسط تابع Dropdown فراخوانی میکنه و ? items.submenu همون شرط مبنا هست، اگر حاصل‌اش غلط باشه، اون وقت یک لینک درست میکنه، اما اگر حاصل‌اش درست باشه یک button درست میکنه ( که کاربر میتونه روش کلیک یا هاور کنه تا زیر منو ( ها ) رو ببینه ) و بعد دوباره خودش رو توسط تابع Dropdown فراخوانی میکنه تا دوباره یک Link درست کنه یا یک button.\n\nاین هم کد CSS تا کد مون بیشتر حس یک نویگیشن ( Navigation ) بده:\n\n```css\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  font-family: sans-serif;\n}\n\nheader {\n  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.07), 0 1px 2px 0 rgba(0, 0, 0, 0.05);\n  color: #212529;\n}\n\n.nav-area {\n  display: flex;\n  align-items: center;\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 10px 20px;\n}\n\n.logo {\n  text-decoration: none;\n  font-size: 25px;\n  color: inherit;\n  margin-right: 20px;\n}\n\n.menus {\n  display: flex;\n  align-items: center;\n  flex-wrap: wrap;\n  list-style: none;\n}\n\n.menu-items {\n  position: relative;\n  font-size: 14px;\n}\n\n.menu-items a {\n  display: block;\n  font-size: inherit;\n  color: inherit;\n  text-decoration: none;\n}\n\n.menu-items button {\n  display: flex;\n  align-items: center;\n  color: inherit;\n  font-size: inherit;\n  border: none;\n  background-color: transparent;\n  cursor: pointer;\n  width: 100%;\n}\n\nbutton span {\n  margin-left: 3px;\n}\n\n.menu-items > a,\n.menu-items button {\n  text-align: left;\n  padding: 0.7rem 1rem;\n}\n\n.menu-items a:hover,\n.menu-items button:hover {\n  background-color: #f2f2f2;\n}\n\n.arrow::after {\n  content: \"\";\n  display: inline-block;\n  margin-left: 0.28em;\n  vertical-align: 0.09em;\n  border-top: 0.42em solid;\n  border-right: 0.32em solid transparent;\n  border-left: 0.32em solid transparent;\n}\n\n.dropdown {\n  position: absolute;\n  left: 0;\n  left: auto;\n  box-shadow: 0 10px 15px -3px rgba(46, 41, 51, 0.08), 0 4px 6px -2px rgba(71, 63, 79, 0.16);\n  font-size: 0.875rem;\n  z-index: 9999;\n  min-width: 10rem;\n  padding: 0.5rem 0;\n  list-style: none;\n  background-color: #fff;\n  border-radius: 0.5rem;\n  display: none;\n}\n\n.dropdown.show {\n  display: block;\n}\n\n.dropdown .dropdown-submenu {\n  position: absolute;\n  left: 100%;\n  top: -7px;\n}\n\n@media (max-width: 1300px) {\n  nav {\n    display: none;\n    max-height: 50vh;\n    overflow-x: hidden;\n    overflow-y: auto;\n  }\n\n  .menus {\n    padding-left: 0px;\n  }\n\n  .dropdown .dropdown-submenu {\n    position: initial;\n  }\n  .dropdown {\n    position: relative;\n    border-radius: 0;\n    box-shadow: none;\n  }\n  header nav {\n    position: absolute;\n    width: 100%;\n    top: 70px;\n    left: 0;\n    background-color: #e5e2ff;\n  }\n  header.active nav {\n    display: initial;\n  }\n  header nav ul li {\n    width: 100%;\n  }\n  header nav ul li ul {\n    position: relative;\n    width: 100%;\n    left: 0;\n  }\n  header ul li ul li ul {\n    top: 0;\n    left: 0;\n  }\n  header nav ul li:hover ul li {\n    background-color: #ffffff;\n  }\n\n  .menuToggle {\n    position: relative;\n    width: 40px;\n    height: 50px;\n    cursor: pointer;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    margin-left: auto;\n  }\n\n  .menuToggle::before {\n    content: \"\";\n    position: absolute;\n    width: 100%;\n    height: 3px;\n    background-color: #000000;\n    transform: translateY(-12px);\n    box-shadow: 0 12px #000000;\n  }\n\n  .menuToggle::after {\n    content: \"\";\n    position: absolute;\n    width: 100%;\n    height: 3px;\n    background-color: #000000;\n    transform: translateY(12px);\n  }\n  header.active .menuToggle::before {\n    transform: rotate(45deg);\n    box-shadow: 0 0 #000000;\n  }\n  header.active .menuToggle::after {\n    transform: rotate(315deg);\n  }\n}\n```\n\n## در نهایت\n\nامیدوارم مفید بوده باشه، اگر شما همچنان متوجه نشدید که یک تابع بازگشتی چیکار میکنه، کاملا طبیعی هست، چون من به صورت مختصر توضیح‌اش دادم، پس خوبه که برید و سرچ کنید."
      }
    ]
  };

export function getAllPosts(locale) {
  if (locale === "en") {
    return enPosts;
  } else {
    return faPosts;
  }
}
